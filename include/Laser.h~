// $Id: Laser.h 536 2007-05-02 14:30:33Z arvid $
#ifndef LASER_H
#define LASER_H
#include <iostream>
#include <string>
#include <vector>
#include <limits>
#include <fstream>      // for Field::Field(filename)
#include "utils.h"      // for skip_comments(std::istream & is)
#include "constant.h"   // for value of pi

using std::cout;
using std::cerr;
using std::vector;
using std::string;
using std::endl;

class Laser; // forward declaration , see below class Field

/**
 * The class Field: *  discretely sampled laser field
 * generated by a Laser or from the E-field data in a file.
 */
class Field {
  public:
  vector<double> t, E[2], A[2], Integral_A[2], Integral_A2[2];        /**< the data */
  vector<double> &Ex, &Ey;    /**< shorthand notation Ex and Ey */
  vector<double> &Ax, &Ay;    /**< shorthand notation Ax and Ay */
  vector<double> &Integral_Ax, &Integral_Ay;    /**< shorthand notation */
  vector<double> &Integral_Ax2, &Integral_Ay2;    /**< shorthand notation */
  bool linear_polarized;   /**< E[1] and A[1] are filled if this is false */

  /// Three possible constructors:
  Field(Laser &l1, double initial_Ax, double initial_Ay);     /**< Field construced from one oscillator */
  Field(Laser &l1, Laser &l2, double delay, double initial_Ax, double initial_Ay); /**< Field construced from two oscillators */
  Field(Laser &l1, Laser &l2, Laser &l3, double delay1, double delay2, double initial_Ax, double initial_Ay); /**< Field construced from two oscillators */
  Field(string filename, double dt, double scaling, double initial_Ax, double initial_Ay); /**< Field construced from file */

};

/**
 * The (Abstract Base Class) Laser
 *
 * you set wavelength_nm and it converts to and uses only w_au
 * you set intensity_wcm2 and it converts to and uses amplitude_au
 *
 * for later convenience there is a t-Axis, giving the time on the
 * simulation clock (should always start at zero, right?, check..)
 *
 * For the definition of ellipticity see
 * http://en.wikipedia.org/wiki/Polarization#Parameterizing_polarization
 *
 */
class Laser {
  double _ellipticity;      /**< ellipticity = e_x/e_y */
  double _pol_angle;
  double ellipt_angle; /**< ellipticity angle = arctan(_ellipticity) */
  double cep;              /**< carrier-envelope phase of the laser */

//double _separation; int _number_in_train;

 public:
  /* ----- named parameters to set optional arguments directly ---- */
  double CEO() { return cep; } /**< accessor for cep */
  void CEO(const double _v) { cep = _v * pi ; } /**< CEO is in units of Pi */

//double separation() {return _separation; }
//int number_in_train() {return _number_in_train; }

  double ellipticity() { return _ellipticity; }/**< accessor for _ellipticity*/
  void ellipticity(const double _v) { /**< set _ellipticity and ellipt_angle */
    _ellipticity=_v; ellipt_angle=atan(_v);
  }

  double pol_angle() { return _pol_angle; }
  void pol_angle(const double _a) {
    _pol_angle=_a;
  }

  /* ----- "public" variables ------------------------------------- */
  double w_au, period_au;  /**< frequency of the laser */
  double amplitude_au;     /**< amplitude of the laser */

  double laser_duration;   /**< stop time of the laser */
  double laser_t_start;
  double time_step;
//double separation; int number_of_train;
  
  /* ----- "public" methods --------------------------------------- */
  double E(const int k, const double t_since_0) const {
    // t_since_0 is the time since the laser started
    // Convert into eigen-time of laser
    double laser_t = get_laser_t(t_since_0);
    if (0==_pol_angle) {
      return envelope(t_since_0)*carrier(k, laser_t);
     
    } else { // rotate \hat{x} to the polarization axis
      switch (k) {
/*         case 0: */
/*           return carrier(0, laser_t) * cos( _pol_angle ) */
/*                - carrier(1, laser_t) * sin( _pol_angle ); */
/*         case 1: */
/*           return carrier(0, laser_t) * sin( _pol_angle ) */
/*                + carrier(1, laser_t) * cos( _pol_angle ); */

      case 0:
	return ( carrier(0, laser_t) * cos( _pol_angle ) - carrier(1, laser_t) * sin( _pol_angle ) )*envelope(t_since_0);
      case 1:
	return (carrier(0, laser_t) * sin( _pol_angle ) + carrier(1, laser_t) * cos( _pol_angle ) )*envelope(t_since_0);

        default:
          cerr<<"No Laser for coordinate "<<k<<"\n";
          exit(1);
      }
    }
  }

  virtual double envelope(const double &) const = 0;  /**<purely virtual */
  /**<overloaded by the derived classes */

  /**
   * The Carrier
   *
   * For the definition of ellipticity see
   * http://en.wikipedia.org/wiki/Polarization#Parameterizing_polarization
   *
   */
  double carrier(const int k, const double &laser_t) const {
    switch (k) {
      case 0:
        return amplitude_au * sin( w_au*laser_t+cep )    // +pi/2. or not
                            * cos( ellipt_angle );
      case 1:
        return amplitude_au * cos( w_au*laser_t+cep )
                            * sin( ellipt_angle );
      default:
        cerr<<"No Laser for coordinate "<<k<<"\n";
        exit(1);
    };
  }
  double Ex(const double &t) const;     /**<abreviation for E(0, t) */
  double Ey(const double &t) const;     /**<abreviation for E(1, t) */

  /* --------------------- Constructor ----------------- */
  Laser(double _wavelength_nm, double _intensity_wcm2, double dt, double _cep, double epsilon, double pol_angle) :
    cep(_cep * pi),
    time_step(dt),
    _ellipticity(epsilon), ellipt_angle( atan(epsilon) ), _pol_angle(pol_angle)
  {
    set_wavelength_nm( _wavelength_nm );
    set_intensity_wcm2( _intensity_wcm2 );
  }
  /**
   * Abstract Classes need a virtual destructor
   */
  virtual ~Laser() = 0;

  /* -----------    Helper functions     -----------   */

 /**
  * convert simulation time into eigen-time of laser
  */  
  double get_laser_t(const double &t_since_0) const {
    return laser_t_start+t_since_0;
  }

 /**
  * set wavelength of the laser
  */  
  void set_wavelength_nm( const double _wavelength_nm ) {
    if ( _wavelength_nm == 0. ) 
      {
	cerr << "wavelength must be /=0.; now omega=0." << "n";
	w_au = 0.0;
        period_au= std::numeric_limits<double>::infinity();
	//      exit(1);
      }
    else
      {
	w_au = 45.5896/_wavelength_nm;
        period_au= 2*pi/w_au;
      }
  } // end of set_wavelength_nm


 /**
  * set intensity of the laser
  */
  void set_intensity_wcm2( const double _intensity_wcm2 ) {
    if ( _intensity_wcm2 < 0. ) 
      {
	cerr << "intensity of the laser must be > =0.; now intensity=0." << "n";
	amplitude_au = 0.;
	//        exit(1);
      }
    else
      {
	amplitude_au = sqrt( _intensity_wcm2/3.5101e+16 );
      }
  } // end of set_intensity_wcm2

}; // end of class Laser
inline Laser::~Laser(){};              /**< gcc-4 demands this */

/**
 * specific Sin2Laser parameters:  N_cycles
 *
 * duration: N_cycles, starting *now* (i.e. at time = 0)
 */
// C++faq-lite calls this a "functionoid"
class Sin2Laser : public Laser {
  public:
  Sin2Laser( double _wavelength_nm, double _intensity_wcm2, double _dt,
             double N_cycles,
             double _cep=0,
             double epsilon=0,
             double pol_angle=0) :
    Laser(_wavelength_nm, _intensity_wcm2, _dt, _cep, epsilon, pol_angle)
  {
    laser_duration = N_cycles*period_au;
    laser_t_start = -laser_duration/2.;
  }    // end of constructor

  virtual double envelope(const double &t_since_0) const {
    // determine the envelope
    if ( t_since_0 < 0 || t_since_0 > laser_duration ) return 0;
    return pow( sin( pi*t_since_0/laser_duration ) , 2 );
  }

}; // end of class Sin2Laser

/**
 * specific GaussLaser parameters:  fwhm_cycles
 *
 * for Gauss pulse with FWHM = fwhm_cycles
 * duration: 2*fwhm_cycles, starting *now* (i.e. at time = 0),
 * centered at fwhm_cycles
 */
class GaussLaser : public Laser 
{ 
  double stdderiv;
  public:

  GaussLaser( double _wavelength_nm, double _intensity_wcm2, double _dt,
              double fwhm_cycles,
              double _cep=0,
              double epsilon=0,
              double pol_angle=0) :
    Laser(_wavelength_nm, _intensity_wcm2, _dt, _cep, epsilon, pol_angle)
  {
    double fwhm_au = fwhm_cycles*period_au;
    //stdderiv=fwhm_au/(2*sqrt(log(2.)));
    stdderiv=fwhm_au/(2*sqrt(2*log(2.)));
    // center laser so that it starts a 1%% of peak intensity
    double sim_t_centerlaser = sqrt(log(1000.))*2*stdderiv; // The intensity is 1/1000
    laser_duration=2*sim_t_centerlaser;
    // Eigen-time of Laser is relative to center of Gaussian
    laser_t_start= -sim_t_centerlaser;
  }    // end of constructor

  virtual double envelope(const double &t_since_0) const {
    // determine the envelope
    if ( t_since_0 < 0 || t_since_0 > laser_duration ) return 0;
    double laser_t = get_laser_t(t_since_0);
    return exp( -pow( laser_t/stdderiv , 2 )/2. );
  }

}; // end of class GaussLaser




class TrainLaser : public Laser
{
  double stdderiv;
  double stdderiv2;
  double separation; int number_in_train; 
 public:

  TrainLaser( double _wavelength_nm, double _intensity_wcm2, double _dt,
              double fwhm_cycles, 
              double fwhm_single , int _number_in_train,double _separation,
              double _cep=0,
              double epsilon=0,
              double pol_angle=0) :
    Laser(_wavelength_nm, _intensity_wcm2, _dt, _cep, epsilon, pol_angle)
  {
    //double fwhm_au = fwhm_single*period_au;
    double fwhm_au = fwhm_cycles*period_au;
    stdderiv=fwhm_au/(2*sqrt(log(2.)));
    stdderiv2=fwhm_single*period_au/(2*sqrt(log(2.)));
    // center laser so that it starts a 1%% of peak intensity
    double sim_t_centerlaser = sqrt(log(500.))*2*stdderiv;// The intensity is 1/1000
    laser_duration=2*sim_t_centerlaser;
    //laser_duration=fwhm_cycles*period_au;

    // Eigen-time of Laser is relative to center of Gaussian
    laser_t_start= -sim_t_centerlaser;
    //laser_t_start= -laser_duration/2.;

    separation=_separation; 
    number_in_train=_number_in_train;
  }    // end of constructor

  virtual double envelope(const double &t_since_0) const {
    // determine the envelope
    if ( t_since_0 < 0 || t_since_0 > laser_duration ) return 0;
    double laser_t = get_laser_t(t_since_0);
    //return exp( -pow( laser_t/stdderiv , 2 )/2. );
    double tmp;

    if (number_in_train%2==1)
      {tmp=0.;
       for (int i=-number_in_train/2;i<=number_in_train/2;i++ )
          tmp=tmp+exp( -pow( (laser_t-i*separation )/stdderiv2 , 2 )/2. );

       //tmp*=exp( -pow( (laser_t )/stdderiv , 2 )/2.);
       return tmp;
      }

    if (number_in_train%2==0)
      {tmp=0.;
       for (int i=-number_in_train/2;i<number_in_train/2;i++ )
          tmp=tmp+exp( -pow( (laser_t-(i+0.5)*separation )/stdderiv2 , 2 )/2. );

       //tmp*=exp( -pow( (laser_t )/stdderiv , 2 )/2.);
       return tmp;
      }

  }

}; // end of class GaussLaser



/**
 * specific RampLaser parameters:  N_cycles, N_rise, N_fall
 *
 * duration: N_cycles
 * Rise & Fall times detemined by N_rise & N_fall
 */
class RampLaser : public Laser
{
  double delta_t_rise, delta_t_fall;
  double N_cycles;
 public:
  
  RampLaser( double _wavelength_nm, double _intensity_wcm2, double _dt,
             double _N_cycles, double _N_rise,
             double _cep=0,
             double epsilon=0,
             double _N_fall=-1,
             double pol_angle=0
             ) :
    Laser(_wavelength_nm, _intensity_wcm2, _dt, _cep, epsilon, pol_angle),
    N_cycles(_N_cycles)
  {
    if ( _N_fall == -1 ) _N_fall=_N_rise; // if N_fall is not given.

    if ( _N_rise+_N_fall > N_cycles ) {
      cerr << "total number of cycles <= number of rising cycles + number of falling cycles" << "n";
      exit( 1 );
    }

    laser_duration = N_cycles*period_au;
    // decision: cep is relative to sim_t=laser_duration/2
    laser_t_start = -laser_duration/2.;
      
    delta_t_rise = _N_rise*period_au;
    N_fall(_N_fall);
  }    // end of constructor

  virtual double envelope(const double &t_since_0) const {
    // determine the envelope
    if ( t_since_0 < 0 || t_since_0 > laser_duration ) return 0;
    if ( t_since_0 < delta_t_rise ) {
      return t_since_0/delta_t_rise;
    }
    else if ( t_since_0 > laser_duration - delta_t_fall ) {
     return ( laser_duration - t_since_0 )/delta_t_fall;
    }
    // else:
    return 1;
  }

  /* ----- named parameters to set optional arguments directly ---- */
  void N_fall(double _v){
    delta_t_fall = _v*period_au;
  };

}; // end of class RampLaser

/**
 * specific CwLaser parameters:  N_cycles
 */
class CwLaser : public Laser
{
 public:
  
  CwLaser( double _wavelength_nm, double _intensity_wcm2, double _dt,
             double N_cycles,
             double _cep=0,
             double epsilon=0,
             double pol_angle=0) :
    Laser(_wavelength_nm, _intensity_wcm2, _dt, _cep, epsilon, pol_angle)
  {
    laser_duration = N_cycles*period_au;
    // decision: cep is relative to sim_t=laser_duration/2
    laser_t_start = -laser_duration/2.;
  }    // end of constructor

  virtual double envelope(const double &t_since_0) const {
    // determine the envelope
    if ( t_since_0 < 0 || t_since_0 > laser_duration ) return 0;
    return 1;
  }

}; // end of class CwLaser


#endif	/* LASER_H */
